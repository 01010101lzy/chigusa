// # Basic grammar elements
Identifier: [a-zA-Z] [_0-9a-zA-Z]* | _ [_0-9a-zA-Z]+

DecimalInteger: "0" | [1-9] [0-9]+
DecimalFractionalPart: "." [0-9]+
DecimalExponentPart: [Ee] [+-]? [0-9]+
HexadecimalNumber: "0x" [0-9a-fA-F]+
IntegerLiteral: (DecimalInteger | HexadecimalNumber) 
FloatLiteral: DecimalInteger DecimalFractionalPart DecimalExponentPart?
    | DecimalInteger DecimalExponentPart

EscapedChar: "\" ([ntrb\\'"] | "u{" [0-9a-fA-F]{4} "}")
Char: [^\\'"] | EscapedChar
CharLiteral: "'" Char "'"
StringLiteral: "\"" Char* "\""

BooleanLiteral: "true" | "false"

Comment: "//" .* "\n"

Literal: IntegerLiteral | FloatLiteral | CharLiteral | StringLiteral | BooleanLiteral

// # Keywords
//
// These keywords may appear in following definitions as their raw forms, 
// i.e. kwReturn as "return".
//
// Most keywords' names are their raw forms prepended by "kw"
kwReturn: "return"
kwAs: "as"
kwIf: "if"
kwWhile: "while"
kwBreak: "break"
kwConst: "const"

// # Items

// The latter `;` is used only for function pointers,
// e.g. `Fn<int, double; bool>` for `bool (int, double)`
GenericTypeAnnotation: "<" TypeDeclaration ("," TypeDeclaration)* (";" TypeDeclaration)? ">"
GenericTypeDeclaration: Identifier GenericTypeAnnotation?
ArrayTypeDeclaration: "[" TypeDeclaration (";" IntegerLiteral)? "]"
ReferenceTypeDeclaration: "&" TypeDeclaration
TypeDeclaration: ReferenceTypeDeclaration | ArrayTypeDeclaration | GenericTypeDeclaration

// # Expressions
//
// "Expression" is abbreviated as "Expr" below.
LiteralExpr: Literal

IdentifierExpr: Identifier<Variable>

// These operators follows the precedence rule defined elsewhere
PrecedingUnaryOperator: "+" | "-" | "*" | "&" | "!" | "~" | "++" | "--"
ProcedingUnaryOperator: "++" | "--"
BinaryOperator: "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "&&" | "||" | ">>" | "<<"
UnaryOperation: PrecedingUnaryOperator Expr | Expr ProcedingUnaryOperator
BinaryOperation: Expr BinaryOperator Expr
OperationExpr: UnaryOperation | BinaryOperation

FnCallExpr: Expr "(" Expr ("," Expr)* ")"

IndexExpr: Expr "[" Expr "]"

StructChildExpr: Expr "." Identifier<StructChild>

StructConstructExpr: Identifier<Type+StructName> "{" (Identifier ":" Expr)* "}"

TypeCastExpr: Expr "as" TypeDefinition

BlockExprBody: Stmt* Expr | Stmt*
BlockExpr: "{" BlockExprBody "}"

Expr: LiteralExpr | IdentifierExpr | OperationExpr | FnCallExpr | IndexExpr 
    | StructChildExpr | StructConstructExpr | TypeCastExpr | IfExpr | WhileExpr

// # Flow Control

IfExpr: "if" "(" Expr<bool|int> ")" BlockExpr ("else" BlockExpr)?
WhileExpr: "while" "(" Expr<bool|int> ")" Stmt
BreakStmt: "break" Expr? ";"
ReturnStmt: "return" Expr? ";"

// # Statements
//
// "Statement" is abbreviated as "Stmt" below.
SingleVarDecl: Identifier ("=" Expr)?
VarDecl: "const"? TypeDeclaration SingleVarDecl ("," SingleVarDecl)+

EmptyStmt: ";"

ExprStmt: Expr ";"

// # Large Structures
FnParamDecl: "(" (TypeDefinition Identifier)* ")"
FnDecl: TypeDefinition Identifier FnParamsDecl (BlockExpr | ";")

// structs are identified directly by their name; no "struct"
StructDecl: "struct" Identifier "{" (TypeDefinition Identifier ",") "}"

Program: (StructDecl | FnDecl | VarDecl)*
