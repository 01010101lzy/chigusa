// # Basic grammar elements
Identifier: [a-zA-Z] [_0-9a-zA-Z]* 

DecimalInteger: "0" | [1-9] [0-9]+
DecimalFractionalPart: "." [0-9]+
DecimalExponentPart: [Ee] [+-]? [0-9]+
HexadecimalNumber: "0x" [0-9a-fA-F]+
// IntegerLiteral: (DecimalInteger | HexadecimalNumber) 
// FloatLiteral: 
//     DecimalInteger DecimalFractionalPart DecimalExponentPart?
//     | DecimalInteger DecimalExponentPart

NumberLiteral: DecimalInteger (
    DecimalFractionalPart DecimalExponentPart?
    | DecimalExponentPart 
)?

EscapedChar: "\" ([ntr\\'"] | "x" HexadecimalNumber{2} | "u" [0-9a-fA-F]{4} )
Char: [^\\'"] | EscapedChar

CharLiteral: "'" Char "'"
StringLiteral: "\"" Char* "\""

BooleanLiteral: "true" | "false"

SingleLineComment: "//" .* "\n"
MultilineComment: "/*" .* "*/"

Literal: IntegerLiteral | FloatLiteral | CharLiteral | StringLiteral | BooleanLiteral


// # Keywords
//
// These keywords may appear in following definitions as their raw forms, 
// i.e. kwReturn as "return".
//
// Most keywords' names are their raw forms prepended by "kw"
kwReturn: "return"
kwAs: "as"
kwIf: "if"
kwWhile: "while"
kwFor: "for"
kwDo: "do"
kwBreak: "break"
kwContinue: "continue"
kwConst: "const"
kwStruct: "struct"
kwSwitch: "switch"
kwCase: "case"
kwDefault: "default"


// # Items

// The latter `;` is used only for function pointers,
// e.g. `Fn<int, double; bool>` for `(int, double) -> bool`
//GenericTypeAnnotation: "<" TypeDeclaration ("," TypeDeclaration)* (";" TypeDeclaration)? ">"

// Generic type, e.g. `Struct<T>`
//GenericTypeDeclaration: Identifier GenericTypeAnnotation?

BasicTypeDeclaration: Identifier 

// Array type, e.g. `[int]`, `[long, 4]`
ArrayTypeDeclaration: "[" TypeDeclaration (";" IntegerLiteral)? "]"

// Reference type, e.g. `&int`, `&Fn<int, double; void>`
ReferenceTypeDeclaration: "&" TypeDeclaration

// Note:
// C0 has 7 types built in:
// - bool (u0)
// - char (u8)
// - int (i32)
// - long (i64)
// - float (f32)
// - double (f64)
// - void 
TypeDeclaration: ReferenceTypeDeclaration | ArrayTypeDeclaration | BasicTypeDeclaration

// # Expressions
//
// "Expression" is abbreviated as "Expr" below.
LiteralExpr: Literal

IdentifierExpr: Identifier<Variable>

// These operators follows the precedence rule defined elsewhere
PrecedingUnaryOperator: "+" | "-" | "*" | "&" | "!" | "~" | "++" | "--"
ProcedingUnaryOperator: "++" | "--"

BinaryOperator: "+" | "-" | "*" | "/" | "%" | "^" 
    | "&" | "|" | "&&" | "||" | ">>" | "<<" | "<" | "<=" | "==" | "!=" | ">=" | ">"

UnaryOperation: PrecedingUnaryOperator Expr | Expr ProcedingUnaryOperator
BinaryOperation: Expr BinaryOperator Expr

OperationExpr: UnaryOperation | BinaryOperation

FnCallExpr: Expr "(" Expr ("," Expr)* ")"

IndexBracket: "[" Expr "]"
IndexExpr: Expr IndexBracket

StructChild: "." Identifier<StructChild>
StructChildExpr: Expr StructChild

StructConstructExpr: Identifier<Type+StructName> "{" (Identifier ":" Expr)* "}"

TypeCastExpr: Expr "as" TypeDefinition


Expr: LiteralExpr | IdentifierExpr | OperationExpr | FnCallExpr | IndexExpr 
    | StructChildExpr | StructConstructExpr | TypeCastExpr

LValue: IdentifierExpr (IndexBracket | StructChildExpr)*
RValue: Expr



// # Statements
//
// "Statement" is abbreviated as "Stmt" below.

// ## Flow Control

IfStmt: "if" "(" Expr<bool|int> ")" BlockExpr ("else" BlockExpr)?

WhileStmt: "while" "(" Expr<bool|int> ")" Stmt

DoWhileStmt: "do" Stmt "while" "(" Expr<bool|int> ")" ";"

ForLoopStmt: "for" "(" VarDecl ";" Expr ";" Expr ")" Stmt

BreakStmt: "break" ";"

ContinueStmt: "continue" ";"

ReturnStmt: "return" Expr? ";"

BlockStmt: "{" Stmt* "}"

// ## Declaration

SingleVarDecl: Identifier ("=" Expr)?
VarDecl: "const"? TypeDeclaration SingleVarDecl ("," SingleVarDecl)?
VarDeclStmt: VarDecl ";"

EmptyStmt: ";"

ExprStmt: Expr ";"

Stmt: IfStmt | WhileStmt | DoWhileStmt | ForLoopStmt | BreakStmt | ContinueStmt 
    | ReturnStmt | VarDeclStmt | ExprStmt | EmptyStmt | BlockStmt



// # Large Structures
FnParamsDecl: "(" (TypeDefinition Identifier ( "," TypeDefiniiton Identifier )* )? ")"
FnDecl: TypeDefinition Identifier FnParamsDecl (BlockExpr | ";")

// structs are identified directly by their name; no "struct"
StructDecl: "struct" Identifier ( "{" (
    TypeDefinition Identifier ( "," TypeDefinition Identifier)* )? "}" )?

Program: (StructDecl | FnDecl | VarDecl)*
