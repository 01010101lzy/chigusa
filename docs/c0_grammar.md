# 对 C0 语法的一些修改

## 运算符

Chigusa 可以识别的运算符（不一定支持）包括：

- `+` 加
- `-` 减（双目）、负（单目前置）
- `*` 乘（双目）、取值（单目前置）
- `/` 除
- `!` 布尔非（单目）
- `&` 按位与（双目）、取址（单目前置）
- `|` 按位或
- `^` 按位异或
- `&&` 布尔与
- `||` 布尔或
- `>` 大于
- `<` 小于
- `>=` 大于等于
- `<=` 小于等于
- `==` 全等于
- `!=` 不等于
- `++` 前置自增（单目前置）、后置自增（单目后置）
- `--` 前置自减（单目前置）、后置自减（单目后置）
- `=` 赋值
- `(` `)` 小括号（优先求值）
- `[` `]` 中括号（下标）
- `{` `}` 大括号（块级作用域）

## 类型声明

为了写起来方便以及什么乱七八糟的原因，Chigusa 可以识别的类型声明格式与 C 的标准稍有不同。具体这些特性会不会支持还没有确定（有时间可能会做），总之先写在这里记录一下思路。

### 基础类型

- `i32`, `int`: 32 位整数
- `u32`, `uint`: 32 位无符号整数

### 指针声明

指针属于类型声明的一部分，如 `int* x, y;` 中 `x` 和 `y` 都是 `int*` 类型。

### 结构体

结构体的声明方式与 C 一致。

### 变量声明

使用 Rust 的风格的数组声明，如 `[int, 4] x = [2, 3, 5, 8];` 相当于 C 中的 `int x[4] = {2, 3, 5, 8};`。数组字面量只允许在初始化赋值过程中出现。

> 这样可以保证如果一行代码以 `[` 开头，可以保证它一定是一个变量声明行。

仅在函数指针声明中支持泛型。如 `Fn<int*, [int, 3], void>` 代表接收两个类型分别为 `int*` 和 `[int, 3]` 的参数、返回值为 `void` 的函数指针。

> 这样可以保证变量声明行的第一个 token 要么是 `[` 要么是类型，不会出现 C 中 `(int*(int, int*)[5])*` 这样令人费解 && 令机器费解的类型声明。

其他示例：

```
const [int, 8] x = [1, 2, 4, 8, 16, 32, 64, 128];

int add(int x, int y) {
    return x + y;
}

Fn<int, int, int> f = add;

int three = f(1, 2);
```
